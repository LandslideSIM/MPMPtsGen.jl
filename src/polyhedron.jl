#==========================================================================================+
|        MaterialPointGenerator.jl: Generate structured material particles in Julia        |
+------------------------------------------------------------------------------------------+
|  File Name  : polyhedron.jl                                                              |
|  Description: Generate structured mesh in 3D space by a given polyhedron                 |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2022                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 01. particle_in_polyhedron!                                                |
|               02. gmsh_mesh3D                                                            |
|               03. polyhedron2particle                                                    |
+==========================================================================================#

export polyhedron2particle

"""
    particle_in_polyhedron!(pts, node, tet, results)

Description:
---
Determine whether a point is inside a polyhedron. This function is able to run on any 
    hardware backends, so the input need to preallocate the results array. Users should not
    call this function directly, please check [`polyhedron2particle`](@ref).
"""
@kernel inbounds = true function particle_in_polyhedron!(pts, node, tet, results)
    i = @index(Global)
    if i ≤ size(pts, 1)
        tets = size(tet, 1)
        inv6 = inv(6.0)
        x, y, z = pts[i, 1], pts[i, 2], pts[i, 3]  # get current particle's position
        for j in 1:tets
            # 获取四面体顶点的坐标索引
            tet_aid, tet_bid, tet_cid, tet_did = tet[j, 1], tet[j, 2], tet[j, 3], tet[j, 4]
            ax, ay, az = node[tet_aid, 1], node[tet_aid, 2], node[tet_aid, 3]
            bx, by, bz = node[tet_bid, 1], node[tet_bid, 2], node[tet_bid, 3]
            cx, cy, cz = node[tet_cid, 1], node[tet_cid, 2], node[tet_cid, 3]
            dx, dy, dz = node[tet_did, 1], node[tet_did, 2], node[tet_did, 3]
            min_x = min(ax, bx, cx, dx)
            max_x = max(ax, bx, cx, dx)
            min_y = min(ay, by, cy, dy)
            max_y = max(ay, by, cy, dy)
            min_z = min(az, bz, cz, dz)
            max_z = max(az, bz, cz, dz)
            if x < min_x || x > max_x || y < min_y || y > max_y || z < min_z || z > max_z
                continue  # 粒子不在该四面体的包围盒内，跳过
            end
            # 计算原四面体的体积
            v0x, v0y, v0z = bx - ax, by - ay, bz - az
            v1x, v1y, v1z = cx - ax, cy - ay, cz - az
            v2x, v2y, v2z = dx - ax, dy - ay, dz - az
            V0 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6
            # 计算包含点 P 和每个面构成的四个四面体的体积
            # 四面体 P, B, C, D
            v0x, v0y, v0z = bx - x, by - y, bz - z
            v1x, v1y, v1z = cx - x, cy - y, cz - z
            v2x, v2y, v2z = dx - x, dy - y, dz - z
            V1 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6
            # 四面体 A, P, C, D
            v0x, v0y, v0z = ax - x, ay - y, az - z
            v1x, v1y, v1z = cx - x, cy - y, cz - z
            v2x, v2y, v2z = dx - x, dy - y, dz - z
            V2 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6
            # 四面体 A, B, P, D
            v0x, v0y, v0z = ax - x, ay - y, az - z
            v1x, v1y, v1z = bx - x, by - y, bz - z
            v2x, v2y, v2z = dx - x, dy - y, dz - z
            V3 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6
            # 四面体 A, B, C, P
            v0x, v0y, v0z = ax - x, ay - y, az - z
            v1x, v1y, v1z = bx - x, by - y, bz - z
            v2x, v2y, v2z = cx - x, cy - y, cz - z
            V4 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6
            # 如果四个体积之和等于原四面体的体积，则点在四面体内
            if abs(V0 - (V1 + V2 + V3 + V4)) < 1e-10
                results[i] = 1  # 点位于四面体内
                break  # 如果在某个四面体内，提前结束循环
            end
        end
    end
end

"""
    gmsh_mesh3D(msh_path::String)

Description:
---
Generate 3D mesh using Gmsh.
"""
@views function gmsh_mesh3D(msh_path::String)
    gmsh.initialize()   # initialize Gmsh
    gmsh.open(msh_path) # load .geo file generated by Gmsh GUI/Script
    # get mesh information
    _, node_coords, _ = gmsh.model.mesh.getNodes() # get all nodes' coordinates
    elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements() # get all elements' information
    # search the type index of tetrahedra elements
    tet_type = 4  # linear tetrahedra type index，（10 is for second-order tetrahedron）
    tet_index = findfirst(==(tet_type), elem_types)
    tet_index === nothing && error("Cannot find tetrahedra elements")
    tet_node_tags = elem_node_tags[tet_index] # extract the node tags of tetrahedra
    # finalize Gmsh
    gmsh.finalize()
    # reshape nodes and elements
    n_nodes = length(node_coords) ÷ 3
    node = Matrix{Float64}(undef, n_nodes, 3)
    @inbounds for i in 1:n_nodes
        node[i, 1] = node_coords[3i-2] # x
        node[i, 2] = node_coords[3i-1] # y
        node[i, 3] = node_coords[3i  ] # z
    end
    n_tetrahedra = length(tet_node_tags) ÷ 4  # 4 nodes in one tetrahedron
    tetrahedra = Matrix{Int}(undef, n_tetrahedra, 4)
    @inbounds for i in 1:n_tetrahedra
        tetrahedra[i, :] = tet_node_tags[(4i-3):(4i)]
    end
    return node, tetrahedra
end

"""
    polyhedron2particle(msh_path::String, lpx, lpy, lpz, ::Val{:CPU})

Description:
---
Generate structured particles from a given polyhedron. Please provide `.msh` file that 
generated by Gmsh GUI/Script.
"""
function polyhedron2particle(msh_path::String, lpx, lpy, lpz, ::Val{:CPU})
    local node, tet
    @MPGsuppress node, tet = gmsh_mesh3D(msh_path)
    # terminal info
    @info """Gmsh results
    number of nodes     : $(size(node, 1))
    number of tetrahedra: $(size(tet, 1))
    """
    # get bounding box for particles
    min_x, max_x = minimum(node[:, 1]), maximum(node[:, 1])
    min_y, max_y = minimum(node[:, 2]), maximum(node[:, 2])
    min_z, max_z = minimum(node[:, 3]), maximum(node[:, 3])
    # generate structured particles
    pts = meshbuilder(min_x:lpx:max_x, min_y:lpy:max_y, min_z:lpz:max_z)
    pts_num = size(pts, 1)
    results = Vector{Bool}(zeros(pts_num))
    particle_in_polyhedron!(CPU())(ndrange=pts_num, pts, node, tet, results)
    return copy(pts[findall(i -> results[i], 1:pts_num), :])
end