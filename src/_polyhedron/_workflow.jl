"""
    readmesh(mesh_file::String; precision="FP32")
Description:
---
Read the mesh file (`.stl`) generated by Gmsh. The function will return the vertices and 
faces for triangle. It's necessary to check the mesh qulity before using this function. 
You can do it in MeshLab or Gmsh GUI. `precision` can be "FP64" or "FP32" in `String`.
"""
function readmesh(mesh_file; precision="FP32")::GmshMesh
    T1 = precision == "FP32" ? Int32 : Int64
    T2 = precision == "FP32" ? Float32 : Float64

    # Initialize gmsh
    gmsh.initialize()
    gmsh.option.setNumber("General.Terminal", 0)
    gmsh.option.setNumber("Mesh.Optimize", 1)
    gmsh.open(mesh_file)

    # Optimize mesh to remove duplicate nodes
    gmsh.model.mesh.optimize("Netgen")

    # Get mesh data
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    num_nodes = length(node_tags)
    vertices = reshape(node_coords, 3, num_nodes)

    # check if the mesh is watertight
    element_types, element_tags, element_node_tags = gmsh.model.mesh.getElements()
    entities = gmsh.model.getEntities(2)  # get all 2d entities
    boundary = gmsh.model.getBoundary(entities, true, true, true)
    isempty(boundary) || error("3D object mesh is not closed")

    gmsh.finalize()
    @info "Mesh data loaded and checking now"

    # Generate vertices and faces in Julia array
    triangle_type = 2
    triangle_index = findfirst(==(triangle_type), element_types)
    isnothing(triangle_index) && error("No triangles found in the mesh")

    triangle_node_tags = element_node_tags[triangle_index]
    num_triangles = length(triangle_node_tags) ÷ 3

    # Map node tags to consecutive indices
    node_map = Dict(tag => i for (i, tag) in enumerate(node_tags))
    faces = reshape(T1.([node_map[tag] for tag in triangle_node_tags]), 3, num_triangles)

    maximum(faces) ≠ size(vertices, 2) && error("Invalid mesh data.")
    @info "Mesh data checked"

    data = [Vector{T2}() for _ in 1:size(faces, 2)]
    @inbounds for i in axes(faces, 2), j in 1:3
        push!(data[i], vertices[1, faces[j, i]])
        push!(data[i], vertices[2, faces[j, i]])
        push!(data[i], vertices[3, faces[j, i]])
    end

    xmin, ymin, zmin = map(x -> minimum(x), eachrow(vertices))
    xmax, ymax, zmax = map(x -> maximum(x), eachrow(vertices))
    bounds = [xmin, ymin, zmin, xmax, ymax, zmax]

    return GmshMesh{T1, T2}(vertices, faces, data, bounds)
end

function _voxelize(meshdata::GmshMesh{T1, T2}, h::Real) where {T1, T2}
    h > 0 || error("h must be positive")
    h = T2(h)
    
    # get bbox of the entire mesh
    mxmin, mxmax = meshdata.bounds[1] - 4h, meshdata.bounds[4] + 4h
    mymin, mymax = meshdata.bounds[2] - 4h, meshdata.bounds[5] + 4h
    mzmin, mzmax = meshdata.bounds[3] - 4h, meshdata.bounds[6] + 4h

    # get the number of elements in x, y, z directions
    nex = ceil(T1, (mxmax - mxmin) / h)
    ney = ceil(T1, (mymax - mymin) / h)
    nez = ceil(T1, (mzmax - mzmin) / h)
    ne  = nex * ney
    
    # update xmax and ymax
    mxmax = mxmin + nex * h
    mymax = mymin + ney * h
    
    # get the number of nodes in x and y directions
    nix = T1(nex + 1)
    niy = T1(ney + 1)
    niz = T1(nez + 1)
    ni  = nix * niy
    
    # initialize the node-to-triangle mapping
    p2t = [Vector{T1}() for _ in 1:ni]
    check_projection!(meshdata, h, p2t, mxmin, mymin, niy)

    # fill the voxels
    pts = zeros(Bool, ni * niz)
    fill_voxel!(pts, p2t, meshdata, niy, mxmin, mymin, mzmin, mxmax, mymax, mzmax, h)
    pts_cen = getpts(pts, nix, niy, niz, h, mxmin, mymin, mzmin)
    coords = populate_pts(pts_cen, h)
    @info "filled with $(size(coords, 1)) particles"

    return coords
end