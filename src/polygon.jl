#==========================================================================================+
|        MaterialPointGenerator.jl: Generate structured material particles in Julia        |
+------------------------------------------------------------------------------------------+
|  File Name  : polygon.jl                                                                 |
|  Description: Generate structured mesh in 2D space by a given polygon                    |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2022                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 01. particle_in_polygon                                                    |
|               02. polygon2particle                                                       |
+==========================================================================================#

export particle_in_polygon
export polygon2particle

"""
    particle_in_polygon(px, py, polygon)

Description:
---
Determine whether a point is inside a polygon. Note the vertices of the polygon should be  
    ordered in a **counterclockwise** manner; otherwise, it may lead to incorrect results.  

(This function is generated by ChatGPT 4o - 2024.10.10)
"""
function particle_in_polygon(px::T, py::T, polygon) where T
    n = size(polygon, 1)
    winding_number = 0
    tol = 1e-10
    @inbounds for i in 1:n
        x1, y1 = polygon[i, :]
        x2, y2 = polygon[mod1(i + 1, n), :]
        
        if y1 ≤ py && y2 > py && (x2 - x1) * (py - y1) > (px - x1) * (y2 - y1) + tol
            winding_number += 1
        elseif y1 > py && y2 ≤ py && (x2 - x1) * (py - y1) < (px - x1) * (y2 - y1) - tol
            winding_number -= 1
        end
    end
    return winding_number ≠ 0
end

"""
    polygon2particle(polygon, lpx, lpy)

Description:
---
Generate structured particles from a given polygon. Note the vertices of the polygon should 
be ordered in a **counterclockwise** manner; otherwise, it may lead to incorrect results.  

`lpx` and `lpy` are the space of particles in `x` and `y` directions, respectively.

`polygon` is the polygon, for example, `polygon = [0 0; 2 0; 2 1; 0 1]` means generate
structured particles in a rectangle area.
"""
@views function polygon2particle(polygon, lpx, lpy)
    # get bounding box for particles
    x_min = minimum(polygon[:, 1])
    x_max = maximum(polygon[:, 1])
    y_min = minimum(polygon[:, 2])
    y_max = maximum(polygon[:, 2])
    offsetx = (x_max - x_min) * 0.2
    offsety = (y_max - y_min) * 0.2
    x_min -= offsetx
    x_max += offsetx
    y_min -= offsety
    y_max += offsety
    # generate structured particles
    mesh = meshbuilder(x_min : lpx : x_max, y_min : lpy : y_max)
    # check if the particle is inside the polygon
    pts = size(mesh, 1)
    rst = Vector{Bool}(undef, pts) 
    @inbounds Threads.@threads for i in 1:pts
        px = mesh[i, 1]
        py = mesh[i, 2]
        rst[i] = particle_in_polygon(px, py, polygon)
    end
    return copy(mesh[findall(rst), :])
end

"""
    polygon2particle(stl_file, output_file, h; verbose=true)

Description:
---
Generate structured particles from a given `.stl` file. The particles are generated by
voxelizing the 2D space of the STL model. The voxel size `h` should be positive.
"""
function polygon2particle(stl_file::String, output_file::String, h; verbose::Bool=true)
    pts, tp = trimesh_voxelize2D(stl_file, h)
    t4 = @elapsed np[].savetxt(output_file, pts, fmt="%.6f", delimiter=" ")
    if verbose
        t1, t2, t3 = tp[1], tp[2], tp[3]
        tt = sum(tp) + t4
        @info """voxelization with trimesh
        - load model  : $(@sprintf("%6.2f", t1)) s | $(@sprintf("%6.2f", 100*t1/tt))%
        - voxelize    : $(@sprintf("%6.2f", t2)) s | $(@sprintf("%6.2f", 100*t2/tt))%
        - fill voxels : $(@sprintf("%6.2f", t3)) s | $(@sprintf("%6.2f", 100*t3/tt))%
        - write .xy   : $(@sprintf("%6.2f", t4)) s | $(@sprintf("%6.2f", 100*t4/tt))%
        $("-"^34)
        - total time  : $(@sprintf("%6.2f", tt)) s
        """
    end
    return nothing
end

"""
    polygon2particle(stl_file, msh_file, output_file, nid_file, h; verbose=true)

Description:
---
Generate structured particles from a given `.stl` file and `.msh` file. The particles are
generated by voxelizing the 2D space of the STL model. The voxel size `h` should be positive.
"""
function polygon2particle(
    stl_file   ::String, 
    msh_file   ::String, 
    output_file::String,
    nid_file   ::String,
    h; 
    verbose    ::Bool=true
)
    pts, nid, tp = trimesh_voxelize2D(stl_file, msh_file, h)
    t4 = @elapsed begin 
        np[].savetxt(output_file, pts, fmt="%.6f", delimiter=" ")
        np[].savetxt(nid_file, nid, fmt="%s", delimiter="\n")
    end
    if verbose
        t1, t2, t3 = tp[1], tp[2], tp[3]
        tt = sum(tp) + t4
        @info """voxelization with trimesh (Gmsh Physical Group)
        - load model    : $(@sprintf("%6.2f", t1)) s | $(@sprintf("%6.2f", 100*t1/tt))%
        - voxelize      : $(@sprintf("%6.2f", t2)) s | $(@sprintf("%6.2f", 100*t2/tt))%
        - fill voxels   : $(@sprintf("%6.2f", t3)) s | $(@sprintf("%6.2f", 100*t3/tt))%
        - write .xy .nid: $(@sprintf("%6.2f", t4)) s | $(@sprintf("%6.2f", 100*t4/tt))%
        $("-"^36)
        - total time    : $(@sprintf("%6.2f", tt)) s
        """
    end
    return nothing
end

function trimesh_voxelize2D(stl_file::String, msh_file::String, h)
    h > 0 || throw(ArgumentError("h must be positive"))

    t1 = @elapsed begin
        mesh = trimesh[].load(stl_file, process=true)
        meshio_mesh = meshio[].read(msh_file)
        physical_group_map = pybuiltins.dict()
        for (name, data) in meshio_mesh.field_data.items() # extract physical group ID & Name
            physical_group_map[np[].int64(data[0])] = name # physical Group ID -> Group Name
        end
        triangle_faces = pybuiltins.list()
        triangle_physical_ids = pybuiltins.list()
        for (cell_type, cell_data) in zip(meshio_mesh.cells, meshio_mesh.cell_data["gmsh:physical"])
            if pyconvert(String, cell_type.type) == "triangle"
                triangle_faces.extend(cell_type.data)
                triangle_physical_ids.extend(cell_data)
            end
        end
        triangle_faces = np[].array(triangle_faces)
        triangle_physical_ids = np[].array(triangle_physical_ids)
        # check .msh == .stl 
        if length(mesh.vertices) ≠ length(meshio_mesh.points) || 
           length(mesh.faces)    ≠ length(triangle_faces)
            error("mismatch between .stl and .msh file geometries")
        end
        z_values = mesh.vertices[pyslice(0, nothing), 2]
        has_non_zero_z = np[].any(z_values != 0)
        if pyconvert(Bool, pybuiltins.bool(has_non_zero_z)) 
            error("STL model must be in 2D space, but found non-zero Z values")
        end
        @info "STL model and Physical group loaded"
    end

    t2 = @elapsed begin
        voxelized = voxelize(mesh, h)
        offset = h * 0.25
        voxelized_filled = voxelized.fill()
        points = voxelized_filled.points
        tmp1, tmp2, triangle_ids = mesh.nearest.on_surface(points)
        voxel_to_group = np[].full(length(points), pybuiltins.None, dtype=pybuiltins.object)
        for (i, triangle_id) in enumerate(triangle_ids)
            if pyconvert(Int, triangle_id) ≥ 0  # 检查 triangle_id 是否有效
                physical_id = triangle_physical_ids[triangle_id]  # 获取对应的 Physical ID
                voxel_to_group[i-1] = physical_group_map.get(physical_id, pybuiltins.None)  # 映射到 Physical Group Name
            end
        end
        nid = np[].repeat(voxel_to_group, 4)
        pts_center = points[pyslice(0, nothing), pyslice(0, 2)]
        @info "voxelized with trimesh"
    end

    t3 = @elapsed begin
        offsets = np[].array([[-offset,  offset], [ offset,  offset],
                              [-offset, -offset], [ offset, -offset]])
        # pts = np[].vstack([pts_center + offset for offset in offsets])
        pts = np[].empty((4 * length(pts_center), 2))  # 初始化新数组，大小为原数组的4倍
        for (i, (x, y)) in enumerate(pts_center)
            idx = (i - 1) * 4
            pts[idx+0][0], pts[idx+0][1] = x - offset, y + offset
            pts[idx+1][0], pts[idx+1][1] = x + offset, y + offset
            pts[idx+2][0], pts[idx+2][1] = x - offset, y - offset
            pts[idx+3][0], pts[idx+3][1] = x + offset, y - offset
        end    
        pts_num = pyconvert(Int, pts.shape[0])
        @info "filled with $(pts_num) particles"
    end
    return pts, nid, [t1, t2, t3]
end

function trimesh_voxelize2D(stl_file::String, h)
    h > 0 || throw(ArgumentError("h must be positive"))
    
    t1 = @elapsed begin
        mesh = trimesh[].load(stl_file, process=true)
        z_values = mesh.vertices[pyslice(0, nothing), 2]
        has_non_zero_z = np[].any(z_values != 0)
        if pyconvert(Bool, pybuiltins.bool(has_non_zero_z)) 
            error("STL model must be in 2D space, but found non-zero Z values")
        end
        @info "STL model loaded"
    end

    t2 = @elapsed begin
        voxelized = voxelize(mesh, h)
        offset = h * 0.25
        voxelized_filled = voxelized.fill()
        points = voxelized_filled.points
        pts_center = points[pyslice(0, nothing), pyslice(0, 2)]
        @info "voxelized with trimesh"
    end

    t3 = @elapsed begin
        offsets = np[].array([[-offset,  offset], [ offset,  offset],
                              [-offset, -offset], [ offset, -offset]])
        pts = np[].vstack([pts_center + offset for offset in offsets])
        pts_num = pyconvert(Int, pts.shape[0])
        @info "filled with $(pts_num) particles"
    end
    return pts, [t1, t2, t3]
end