#==========================================================================================+
|        MaterialPointGenerator.jl: Generate structured material particles in Julia        |
+------------------------------------------------------------------------------------------+
|  File Name  : polygon.jl                                                                 |
|  Description: Generate structured mesh in 2D space by a given polygon                    |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2022                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 01. particle_in_polygon                                                    |
|               02. polygon2particle                                                       |
+==========================================================================================#

export particle_in_polygon
export polygon2particle

"""
    particle_in_polygon(px, py, polygon)

Description:
---
Determine whether a point is inside a polygon. Note the vertices of the polygon should be  
    ordered in a **counterclockwise** manner; otherwise, it may lead to incorrect results.  

(This function is generated by ChatGPT 4o - 2024.10.10)
"""
function particle_in_polygon(px::T, py::T, polygon) where T
    n = size(polygon, 1)
    winding_number = 0
    tol = 1e-10
    @inbounds for i in 1:n
        x1, y1 = polygon[i, :]
        x2, y2 = polygon[mod1(i + 1, n), :]
        
        if y1 ≤ py && y2 > py && (x2 - x1) * (py - y1) > (px - x1) * (y2 - y1) + tol
            winding_number += 1
        elseif y1 > py && y2 ≤ py && (x2 - x1) * (py - y1) < (px - x1) * (y2 - y1) - tol
            winding_number -= 1
        end
    end
    return winding_number ≠ 0
end

"""
    polygon2particle(domain, lpx, lpy)

Description:
---
Generate structured particles from a given polygon. Note the vertices of the polygon should 
be ordered in a **counterclockwise** manner; otherwise, it may lead to incorrect results.  

`lpx` and `lpy` are the space of particles in `x` and `y` directions, respectively.

`domain` is the polygon, for example, `domain = [0 0; 2 0; 2 1; 0 1]` means generate
structured particles in a rectangle area.
"""
@views function polygon2particle(polygon, lpx, lpy)
    # get bounding box for particles
    x_min = minimum(polygon[:, 1])
    x_max = maximum(polygon[:, 1])
    y_min = minimum(polygon[:, 2])
    y_max = maximum(polygon[:, 2])
    offsetx = (x_max - x_min) * 0.2
    offsety = (y_max - y_min) * 0.2
    x_min -= offsetx
    x_max += offsetx
    y_min -= offsety
    y_max += offsety
    # generate structured particles
    mesh = meshbuilder(x_min : lpx : x_max, y_min : lpy : y_max)
    # check if the particle is inside the polygon
    pts = size(mesh, 1)
    rst = Vector{Bool}(undef, pts) 
    @inbounds Threads.@threads for i in 1:pts
        px = mesh[i, 1]
        py = mesh[i, 2]
        rst[i] = particle_in_polygon(px, py, polygon)
    end
    return copy(mesh[findall(rst), :])
end

function polygon2particle(stl_file::String, output_file::String, lp; verbose::Bool=true)
    pts, tp = trimesh_voxelize2D(stl_file, lp)
    t4 = @elapsed np[].savetxt(output_file, pts, fmt="%.6f", delimiter=" ")
    if verbose
        t1, t2, t3 = tp[1], tp[2], tp[3]
        tt = sum(tp) + t4
        @info """voxelization with trimesh
        - load model  : $(@sprintf("%6.2f", t1)) s | $(@sprintf("%6.2f", 100*t1/tt))%
        - voxelize    : $(@sprintf("%6.2f", t2)) s | $(@sprintf("%6.2f", 100*t2/tt))%
        - fill voxels : $(@sprintf("%6.2f", t3)) s | $(@sprintf("%6.2f", 100*t3/tt))%
        - write .xy   : $(@sprintf("%6.2f", t4)) s | $(@sprintf("%6.2f", 100*t4/tt))%
        $("-"^34)
        - total time  : $(@sprintf("%6.2f", tt)) s
        """
    end
    return nothing
end

function trimesh_voxelize2D(stl_file::String, lp)
    lp > 0 || throw(ArgumentError("lp must be positive"))
    
    t1 = @elapsed begin
        mesh = trimesh[].load(stl_file, process=true)
        z_values = mesh.vertices[pyslice(0, nothing), 2]
        has_non_zero_z = np[].any(z_values != 0)
        if pyconvert(Bool, pybuiltins.bool(has_non_zero_z)) 
            error("STL model must be in 2D space, but found non-zero Z values")
        end
        @info "STL model loaded"
    end

    t2 = @elapsed begin
        voxelized = voxelize(mesh, lp)
        offset = lp * 0.25
        voxelized_filled = voxelized.fill()
        points = voxelized_filled.points
        pts_center = points[pyslice(0, nothing), pyslice(0, 2)]
        @info "voxelized with trimesh"
    end

    t3 = @elapsed begin
        offsets = np[].array([[-offset,  offset], [ offset,  offset],
                              [-offset, -offset], [ offset, -offset]])
        pts = np[].vstack([pts_center + offset for offset in offsets])
        pts_num = pyconvert(Int, pts.shape[0])
        @info "filled with $(pts_num) particles"
    end
    return pts, [t1, t2, t3]
end